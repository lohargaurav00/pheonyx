// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

/// Starts an mDNS server for device discovery on the local network.
///
/// # Arguments
///
/// * `dur` - Optional duration (in seconds) to run the server before shutting down.
/// If `None`, the server runs for 5 seconds.
///
/// # Returns
///
/// * `Result<()>` - Returns `Ok(())` if the server starts successfully, otherwise an error.
Future<void> startMdnsServer({int? dur}) =>
    RustLib.instance.api.crateApiBridgeStartMdnsServer(dur: dur);

/// Creates a new instance of the `MdnsServer`.
///
/// This can be used to register and discover devices on the local network
/// via mDNS (Multicast DNS).
///
/// # Returns
///
/// * `MdnsServer` - A new, unstarted mDNS server instance.
MdnsServer createMdnsServerDaimon() =>
    RustLib.instance.api.crateApiBridgeCreateMdnsServerDaimon();

/// Starts the given mDNS server instance.
///
/// This begins advertising the service on the local network for discovery.
/// Should be called after creating the server.
///
/// # Arguments
///
/// * `server` - A mutable reference to an `MdnsServer`.
///
/// # Returns
///
/// * `Result<()>` - Returns `Ok(())` if the server starts successfully, otherwise an error.
void startMdnsDaimon({required MdnsServer server}) =>
    RustLib.instance.api.crateApiBridgeStartMdnsDaimon(server: server);

/// Stops the given mDNS server instance.
///
/// This halts any ongoing mDNS advertisement and removes the service
/// from the local network.
///
/// # Arguments
///
/// * `server` - A mutable reference to an `MdnsServer`.
void stopMdnsDaimon({required MdnsServer server}) =>
    RustLib.instance.api.crateApiBridgeStopMdnsDaimon(server: server);

/// Checks whether the given mDNS server instance is currently running.
///
/// # Arguments
///
/// * `server` - A reference to an `MdnsServer`.
///
/// # Returns
///
/// * `bool` - `true` if the server is running, `false` otherwise.
bool mdnsDaimonRunning({required MdnsServer server}) =>
    RustLib.instance.api.crateApiBridgeMdnsDaimonRunning(server: server);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< MdnsServer>>
abstract class MdnsServer implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UdpClient>>
abstract class UdpClient implements RustOpaqueInterface {
  Future<void> connect({required int port, required String ip});

  factory UdpClient() => RustLib.instance.api.crateApiBridgeUdpClientNew();

  Stream<UdpPacket> receiveStream();

  Future<void> sendMessage({required String message});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UdpPacket>>
abstract class UdpPacket implements RustOpaqueInterface {
  SocketAddr get addr;

  String get data;

  set addr(SocketAddr addr);

  set data(String data);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UdpServer>>
abstract class UdpServer implements RustOpaqueInterface {
  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<UdpServer> newInstance({required int port}) =>
      RustLib.instance.api.crateApiBridgeUdpServerNew(port: port);

  Stream<UdpPacket> receiveStream();

  Future<void> run();

  Future<void> sendMessage({required String msg});
}
